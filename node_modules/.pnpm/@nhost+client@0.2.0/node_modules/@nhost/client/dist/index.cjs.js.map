{
  "version": 3,
  "sources": ["../src/index.ts", "../src/client.ts", "../src/machines/index.ts", "../src/constants.ts", "../src/errors.ts", "../src/hasura-auth.ts", "../src/validators.ts", "../src/machines/context.ts", "../src/machines/change-email.ts", "../src/machines/change-password.ts", "../src/machines/reset-password.ts", "../src/storage.ts", "../src/coookie-client.ts"],
  "sourcesContent": ["export type { NhostClientOptions } from './client'\nexport { Nhost } from './client'\nexport * from './constants'\nexport { NhostSSR } from './coookie-client'\nexport * from './machines'\nexport * from './storage'\nexport * from './types'\n", "import { BroadcastChannel } from 'broadcast-channel'\nimport { InterpreterFrom } from 'xstate'\n\nimport { createNhostMachine, NhostMachine, NhostMachineOptions } from './machines'\nimport { defaultStorageGetter, defaultStorageSetter } from './storage'\n\nexport type NhostClientOptions = NhostMachineOptions\n\nexport class Nhost {\n  readonly backendUrl: string\n  readonly clientUrl: string\n  readonly machine: NhostMachine\n  interpreter?: InterpreterFrom<NhostMachine>\n  #channel?: BroadcastChannel\n\n  constructor({\n    backendUrl,\n    clientUrl = typeof window !== 'undefined' ? window.location.origin : '',\n    storageGetter = defaultStorageGetter,\n    storageSetter = defaultStorageSetter,\n    autoSignIn = true,\n    autoRefreshToken = true\n  }: NhostClientOptions) {\n    this.backendUrl = backendUrl\n    this.clientUrl = clientUrl\n\n    const machine = createNhostMachine({\n      backendUrl,\n      clientUrl,\n      storageGetter,\n      storageSetter,\n      autoSignIn,\n      autoRefreshToken\n    })\n\n    this.machine = machine\n\n    if (typeof window !== 'undefined' && autoSignIn) {\n      this.#channel = new BroadcastChannel<string>('nhost')\n      this.#channel.addEventListener('message', (token) => {\n        const existingToken = this.interpreter?.state.context.refreshToken\n        if (this.interpreter && token !== existingToken) {\n          this.interpreter.send({ type: 'TRY_TOKEN', token })\n        }\n      })\n    }\n  }\n}\n", "import type { AxiosRequestConfig, AxiosResponse } from 'axios'\nimport { BroadcastChannel } from 'broadcast-channel'\nimport produce from 'immer'\nimport { assign, createMachine } from 'xstate'\n\nimport {\n  MIN_TOKEN_REFRESH_INTERVAL,\n  NHOST_JWT_EXPIRES_AT_KEY,\n  NHOST_REFRESH_TOKEN_KEY,\n  TOKEN_REFRESH_MARGIN\n} from '../constants'\nimport { INVALID_EMAIL_ERROR, INVALID_PASSWORD_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { StorageGetter, StorageSetter } from '../storage'\nimport { isValidEmail, isValidPassword } from '../validators'\n\nimport { INITIAL_MACHINE_CONTEXT, NhostContext } from './context'\nimport { NhostEvents } from './events'\n\nexport type { NhostContext, NhostEvents }\nexport * from './change-email'\nexport * from './change-password'\nexport * from './reset-password'\n\nexport type NhostMachineOptions = {\n  backendUrl: string\n  clientUrl?: string\n  storageGetter?: StorageGetter\n  storageSetter?: StorageSetter\n  autoSignIn?: boolean\n  autoRefreshToken?: boolean\n}\n\nexport type NhostMachine = ReturnType<typeof createNhostMachine>\n\nexport const createNhostMachine = ({\n  backendUrl,\n  clientUrl,\n  storageSetter,\n  storageGetter,\n  autoRefreshToken = true,\n  autoSignIn = true\n}: Required<NhostMachineOptions>) => {\n  const api = nhostApiClient(backendUrl)\n  const postRequest = async <T = any, R = AxiosResponse<T>, D = any>(\n    url: string,\n    data?: D,\n    config?: AxiosRequestConfig<D>\n  ): Promise<R> => {\n    const result = await api.post(url, data, config)\n    return result.data\n  }\n  return createMachine(\n    {\n      schema: {\n        context: {} as NhostContext,\n        events: {} as NhostEvents\n      },\n      tsTypes: {} as import('./index.typegen').Typegen0,\n      context: produce<NhostContext>(INITIAL_MACHINE_CONTEXT, (ctx) => {\n        const expiresAt = storageGetter(NHOST_JWT_EXPIRES_AT_KEY)\n        if (expiresAt) ctx.accessToken.expiresAt = new Date(expiresAt)\n        ctx.refreshToken.value = storageGetter(NHOST_REFRESH_TOKEN_KEY)\n      }),\n      id: 'nhost',\n      type: 'parallel',\n      states: {\n        authentication: {\n          initial: 'checkAutoSignIn',\n          on: {\n            TRY_TOKEN: '#nhost.token.running',\n            SESSION_UPDATE: [\n              {\n                cond: 'hasSession',\n                actions: ['saveSession', 'persist', 'resetTimer'],\n                target: '.signedIn'\n              }\n            ]\n          },\n          states: {\n            checkAutoSignIn: {\n              always: [{ cond: 'isAutoSignInDisabled', target: 'starting' }],\n              invoke: [\n                {\n                  id: 'autoSignIn',\n                  src: 'autoSignIn',\n                  onDone: {\n                    target: 'signedIn',\n                    actions: ['saveSession', 'persist']\n                  },\n                  onError: 'starting'\n                }\n              ]\n            },\n            starting: {\n              always: [\n                {\n                  cond: 'isSignedIn',\n                  target: 'signedIn'\n                },\n                {\n                  cond: 'hasRefreshTokenWithoutSession',\n                  target: ['authenticating.token', '#nhost.token.running']\n                },\n                'signedOut'\n              ]\n            },\n            signedOut: {\n              tags: ['ready'],\n              initial: 'noErrors',\n              states: {\n                noErrors: {},\n                success: {},\n                needsVerification: {},\n                failed: {\n                  exit: 'resetAuthenticationError',\n                  initial: 'server',\n                  states: {\n                    server: {\n                      entry: 'saveAuthenticationError'\n                    },\n                    validation: {\n                      states: {\n                        password: {\n                          entry: 'saveInvalidPassword'\n                        },\n                        email: {\n                          entry: 'saveInvalidEmail'\n                        }\n                      }\n                    }\n                  }\n                },\n                signingOut: {\n                  entry: 'destroyToken',\n                  invoke: {\n                    src: 'signout',\n                    id: 'signingOut',\n                    onDone: 'success',\n                    onError: 'failed.server' // TODO save error\n                  }\n                }\n              },\n              on: {\n                // TODO change input validation - see official xstate form example\n                SIGNIN_PASSWORD: [\n                  {\n                    cond: 'invalidEmail',\n                    target: '.failed.validation.email'\n                  },\n                  {\n                    cond: 'invalidPassword',\n                    target: '.failed.validation.password'\n                  },\n                  '#nhost.authentication.authenticating.password'\n                ],\n                SIGNIN_PASSWORDLESS_EMAIL: [\n                  {\n                    cond: 'invalidEmail',\n                    target: '.failed.validation.email'\n                  },\n                  '#nhost.authentication.authenticating.passwordlessEmail'\n                ],\n                SIGNUP_EMAIL_PASSWORD: [\n                  {\n                    cond: 'invalidEmail',\n                    target: '.failed.validation.email'\n                  },\n                  {\n                    cond: 'invalidPassword',\n                    target: '.failed.validation.password'\n                  },\n                  '#nhost.authentication.registering'\n                ],\n                SIGNIN_ANONYMOUS: '#nhost.authentication.authenticating.anonymous'\n              }\n            },\n            authenticating: {\n              states: {\n                passwordlessEmail: {\n                  invoke: {\n                    src: 'signInPasswordlessEmail',\n                    id: 'authenticatePasswordlessEmail',\n                    onDone: '#nhost.authentication.signedOut.needsVerification',\n                    onError: '#nhost.authentication.signedOut.failed.server'\n                  }\n                },\n                password: {\n                  invoke: {\n                    src: 'signInPassword',\n                    id: 'authenticateUserWithPassword',\n                    onDone: {\n                      actions: ['saveSession', 'persist'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: '#nhost.authentication.signedOut.needsVerification'\n                      },\n                      {\n                        target: '#nhost.authentication.signedOut.failed.server'\n                      }\n                    ]\n                  }\n                },\n                token: {},\n                anonymous: {\n                  invoke: {\n                    src: 'signInAnonymous',\n                    id: 'authenticateAnonymously',\n                    onDone: {\n                      actions: ['saveSession', 'persist'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: '#nhost.authentication.signedOut.failed.server'\n                  }\n                }\n              }\n            },\n            registering: {\n              invoke: {\n                src: 'registerUser',\n                id: 'registerUser',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    target: '#nhost.authentication.signedIn',\n                    actions: ['saveSession', 'persist']\n                  },\n                  {\n                    target: '#nhost.authentication.signedOut.needsVerification'\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: '#nhost.authentication.signedOut.needsVerification'\n                  },\n                  {\n                    actions: 'saveRegisrationError',\n                    target: '#nhost.authentication.signedOut.failed.server'\n                  }\n                ]\n              }\n            },\n\n            signedIn: {\n              tags: ['ready'],\n              type: 'parallel',\n              on: {\n                SIGNOUT: '#nhost.authentication.signedOut.signingOut'\n              },\n              states: {\n                refreshTimer: {\n                  id: 'timer',\n                  initial: 'idle',\n                  states: {\n                    disabled: { type: 'final' },\n                    stopped: {\n                      always: {\n                        cond: 'noToken',\n                        target: 'idle'\n                      }\n                    },\n                    idle: {\n                      always: [\n                        { cond: 'isAutoRefreshDisabled', target: 'disabled' },\n                        {\n                          cond: 'hasRefreshToken',\n                          target: 'running'\n                        }\n                      ]\n                    },\n                    running: {\n                      initial: 'pending',\n                      entry: 'resetTimer',\n                      states: {\n                        pending: {\n                          after: {\n                            '1000': {\n                              actions: 'tickRefreshTimer',\n                              internal: false,\n                              target: 'pending'\n                            }\n                          },\n                          always: {\n                            cond: 'refreshTimerShouldRefresh',\n                            target: 'refreshing'\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: 'refreshToken',\n                            id: 'refreshToken',\n                            onDone: {\n                              actions: ['saveSession', 'persist', 'resetTimer'],\n                              target: 'pending'\n                            },\n                            onError: [\n                              // TODO\n                              // {\n                              //   actions: 'retry',\n                              //   cond: 'canRetry',\n                              //   target: 'pending'\n                              // },\n                              // {\n                              //   actions: ['sendError', 'resetToken'],\n                              //   target: '#timer.stopped'\n                              // }\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: 'idle',\n          states: {\n            idle: {},\n            running: {\n              invoke: {\n                src: 'refreshToken',\n                id: 'authenticateWithToken',\n                onDone: {\n                  actions: ['saveSession', 'persist'],\n                  target: ['#nhost.authentication.signedIn', 'idle']\n                },\n                onError: {\n                  target: ['#nhost.authentication.signedOut', 'idle']\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        // TODO better naming\n        saveSession: assign({\n          // TODO type\n          user: (_, e: any) => e.data?.session?.user,\n          accessToken: (_, e) => ({\n            value: e.data?.session?.accessToken,\n            expiresAt: new Date(Date.now() + e.data?.session?.accessTokenExpiresIn * 1_000)\n          }),\n          refreshToken: (_, e) => ({ value: e.data?.session?.refreshToken }),\n          mfa: (_, e) => e.data?.mfa ?? false\n        }),\n\n        resetTimer: assign({\n          refreshTimer: (ctx, e) => {\n            return {\n              elapsed: 0,\n              attempts: 0\n            }\n          }\n        }),\n\n        tickRefreshTimer: assign({\n          refreshTimer: (ctx, e) => {\n            return {\n              elapsed: ctx.refreshTimer.elapsed + 1,\n              attempts: ctx.refreshTimer.attempts\n            }\n          }\n        }),\n\n        // * Authenticaiton errors\n        saveAuthenticationError: assign({\n          // TODO type\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, authentication: error })\n        }),\n        resetAuthenticationError: assign({\n          errors: ({ errors: { authentication, ...errors } }) => errors\n        }),\n        saveInvalidEmail: assign({\n          errors: ({ errors }) => ({ ...errors, authentication: INVALID_EMAIL_ERROR })\n        }),\n        saveInvalidPassword: assign({\n          errors: ({ errors }) => ({ ...errors, authentication: INVALID_PASSWORD_ERROR })\n        }),\n\n        saveRegisrationError: assign({\n          // TODO type\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, registration: error })\n        }),\n        // * Persist the refresh token and the jwt expiration outside of the machine\n        persist: (_, { data }: any) => {\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, data.session.refreshToken)\n          if (data.session.accessTokenExpiresIn) {\n            const nextRefresh = new Date(\n              Date.now() + data.session.accessTokenExpiresIn * 1_000\n            ).toISOString()\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh)\n          } else {\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          }\n        },\n        destroyToken: () => {\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n        }\n      },\n\n      guards: {\n        isSignedIn: (ctx) => !!ctx.user && !!ctx.refreshToken.value && !!ctx.accessToken.value,\n        hasRefreshTokenWithoutSession: (ctx) =>\n          !!ctx.refreshToken.value && !ctx.user && !ctx.accessToken.value,\n        noToken: (ctx) => !ctx.refreshToken.value,\n        hasRefreshToken: (ctx) => !!ctx.refreshToken.value,\n        isAutoRefreshDisabled: () => !autoRefreshToken,\n        isAutoSignInDisabled: () => !autoSignIn,\n        refreshTimerShouldRefresh: (ctx) =>\n          ctx.refreshTimer.elapsed >\n          Math.max(\n            (Date.now() - ctx.accessToken.expiresAt.getTime()) / 1_000 - TOKEN_REFRESH_MARGIN,\n            MIN_TOKEN_REFRESH_INTERVAL\n          ),\n\n        // * Authentication errors\n        // TODO type\n        unverified: (ctx, { data: { error } }: any) =>\n          error.status === 401 && error.message === 'Email is not verified',\n\n        // * Event guards\n        // TODO type\n        hasSession: (_, e: any) => !!e.data?.session,\n        invalidEmail: (_, { email }) => !isValidEmail(email),\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n\n      services: {\n        signInPassword: (_, { email, password }) =>\n          postRequest('/v1/auth/signin/email-password', {\n            email,\n            password\n          }),\n        signInPasswordlessEmail: (_, { email, options }) =>\n          postRequest('/v1/auth/signin/passwordless/email', {\n            email,\n            options: {\n              ...options,\n              redirectTo: options?.redirectTo?.startsWith('/')\n                ? clientUrl + options.redirectTo\n                : options?.redirectTo\n            }\n          }),\n        signInAnonymous: (_) => postRequest('/v1/auth/signin/anonymous'),\n        refreshToken: async (ctx, event) => {\n          const refreshToken = event.type === 'TRY_TOKEN' ? event.token : ctx.refreshToken.value\n          const session = await postRequest('/v1/auth/token', {\n            refreshToken\n          })\n          return { session }\n        },\n        signout: (ctx, e) =>\n          postRequest('/v1/auth/signout', {\n            refreshToken: ctx.refreshToken.value,\n            all: !!e.all\n          }),\n\n        registerUser: (_, { email, password, options }) =>\n          postRequest('/v1/auth/signup/email-password', {\n            email,\n            password,\n            options: {\n              ...options,\n              redirectTo: options?.redirectTo?.startsWith('/')\n                ? clientUrl + options.redirectTo\n                : options?.redirectTo\n            }\n          }),\n\n        autoSignIn: async () => {\n          if (typeof window !== 'undefined') {\n            const location = window.location\n            if (location.hash) {\n              const params = new URLSearchParams(location.hash.slice(1))\n              const refreshToken = params.get('refreshToken')\n              if (refreshToken) {\n                const session = await postRequest('/v1/auth/token', {\n                  refreshToken\n                })\n                // * remove hash from the current url after consumming the token\n                window.history.pushState({}, '', location.pathname)\n                const channel = new BroadcastChannel('nhost')\n                // TODO broadcat session instead of token\n                channel.postMessage(refreshToken)\n                return { session }\n              }\n            }\n            throw Error()\n          }\n        }\n      }\n    }\n  )\n}\n", "export const NHOST_REFRESH_TOKEN_KEY = 'nhostRefreshToken'\nexport const NHOST_JWT_EXPIRES_AT_KEY = 'nhostRefreshTokenExpiresAt'\n\nexport const MIN_PASSWORD_LENGTH = 3\n\n// * Minimum time in seconds before the JWT expiration and the first refresh attempt\nexport const TOKEN_REFRESH_MARGIN = 900\n\n// * Minimum time in seconds for a refresh regardless ot the JWT expiration\nexport const MIN_TOKEN_REFRESH_INTERVAL = 60\n\n// * Number of seconds before retrying a token refresh after an error\nexport const REFRESH_TOKEN_RETRY_INTERVAL = 10\n\n// * Maximum number of attempts to refresh a token before stopping the timer and logging out\n// TODO try when offline for a long time: maybe we could keep state as 'signedIn'\nexport const REFRESH_TOKEN_RETRY_MAX_ATTEMPTS = 30\n", "export const NETWORK_ERROR_CODE = 0\nexport const VALIDATION_ERROR_CODE = 10\n\nexport type ErrorPayload = {\n  error: string\n  status: number\n  message: string\n}\n\nexport type ValidationErrorPayload = ErrorPayload & { status: typeof VALIDATION_ERROR_CODE }\n\nexport const INVALID_EMAIL_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-email',\n  message: 'Email is incorrectly formatted'\n}\n\nexport const INVALID_PASSWORD_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-password',\n  message: 'Password is incorrectly formatted'\n}\n", "import axios, { AxiosError } from 'axios'\n\nimport { NETWORK_ERROR_CODE } from './errors'\n\nexport const nhostApiClient = (backendUrl: string) => {\n  const client = axios.create({ baseURL: backendUrl })\n\n  client.interceptors.response.use(\n    (response) => response,\n    (error: AxiosError<{ message: string; error?: string; statusCode?: number }>) =>\n      Promise.reject({\n        error: {\n          message:\n            error.response?.data?.message ??\n            error.message ??\n            error.request.responseText ??\n            JSON.stringify(error),\n          status: error.response?.status ?? error.response?.data.statusCode ?? NETWORK_ERROR_CODE,\n          error: error.response?.data.error || error.request.statusText || 'network'\n        }\n      })\n  )\n  return client\n}\n", "import { MIN_PASSWORD_LENGTH } from './constants'\n\nexport const isValidEmail = (email?: string | null) =>\n  !!email &&\n  typeof email === 'string' &&\n  String(email)\n    .toLowerCase()\n    .match(\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    )\n\nexport const isValidPassword = (password?: string | null) =>\n  !!password && typeof password === 'string' && password.length >= MIN_PASSWORD_LENGTH\n", "import { ErrorPayload } from '../errors'\nimport { User } from '../types'\n\nexport type NhostContext = {\n  user: User | null\n  mfa: boolean\n  accessToken: {\n    value: string | null\n    expiresAt: Date\n  }\n  refreshTimer: {\n    elapsed: number\n    attempts: number\n  }\n  refreshToken: {\n    value: string | null\n  }\n  errors: Partial<Record<'registration' | 'authentication', ErrorPayload>>\n}\n\nexport const INITIAL_MACHINE_CONTEXT: NhostContext = {\n  user: null,\n  mfa: false,\n  accessToken: {\n    value: null,\n    expiresAt: new Date()\n  },\n  refreshTimer: {\n    elapsed: 0,\n    attempts: 0\n  },\n  refreshToken: {\n    value: null\n  },\n  errors: {}\n}\n", "import { assign, createMachine } from 'xstate'\n\nimport { Nhost } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ChangeEmailOptions } from '../types'\nimport { isValidEmail } from '../validators'\n\nexport type ChangeEmailContext = {\n  error: ErrorPayload | null\n}\nexport type ChangeEmailEvents = {\n  type: 'REQUEST_CHANGE'\n  email?: string\n  options?: ChangeEmailOptions\n}\n\nexport const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }: Nhost) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangeEmailContext,\n        events: {} as ChangeEmailEvents\n      },\n      tsTypes: {} as import('./change-email.typegen').Typegen0,\n      id: 'changeEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST_CHANGE: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: 'idle.success',\n            onError: { actions: 'saveRequestError', target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // TODO type\n          error: (_, { data: { error } }: any) => error\n        })\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: async (_, { email, options }) => {\n          const res = await api.post(\n            '/v1/auth/user/email/change',\n            {\n              newEmail: email,\n              options: {\n                redirectTo: options?.redirectTo?.startsWith('/')\n                  ? clientUrl + options.redirectTo\n                  : options?.redirectTo\n              }\n            },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n", "import { assign, createMachine } from 'xstate'\n\nimport { Nhost } from '../client'\nimport { ErrorPayload, INVALID_PASSWORD_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { isValidPassword } from '../validators'\n\nexport type ChangePasswordContext = {\n  error: ErrorPayload | null\n}\nexport type ChangePasswordEvents = {\n  type: 'REQUEST_CHANGE'\n  password?: string\n}\n\nexport const createChangePasswordMachine = ({ backendUrl, interpreter }: Nhost) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangePasswordContext,\n        events: {} as ChangePasswordEvents\n      },\n      tsTypes: {} as import('./change-password.typegen').Typegen0,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST_CHANGE: [\n              {\n                cond: 'invalidPassword',\n                actions: 'saveInvalidPasswordError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: 'idle.success',\n            onError: { actions: 'saveRequestError', target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),\n        saveRequestError: assign({\n          // TODO type\n          error: (_, { data: { error } }: any) => {\n            console.log(error)\n            return error\n          }\n        })\n      },\n      guards: {\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n      services: {\n        requestChange: (_, { password }) =>\n          api.post<string, { data: { error?: ErrorPayload } }>(\n            '/v1/auth/user/password',\n            { newPassword: password },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n      }\n    }\n  )\n}\n", "import { assign, createMachine } from 'xstate'\n\nimport { Nhost } from '../client'\nimport { ErrorPayload } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ResetPasswordOptions } from '../types'\n\nexport type ResetPasswordContext = {\n  error: ErrorPayload | null\n}\nexport type ResetPasswordEvents = {\n  type: 'REQUEST_CHANGE'\n  email?: string\n  options?: ResetPasswordOptions\n}\n\nexport const createResetPasswordMachine = ({ backendUrl, clientUrl }: Nhost) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ResetPasswordContext,\n        events: {} as ResetPasswordEvents\n      },\n      tsTypes: {} as import('./reset-password.typegen').Typegen0,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST_CHANGE: 'requesting'\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: 'idle.success',\n            onError: { actions: 'saveRequestError', target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveRequestError: assign({\n          // TODO type\n          error: (_, { data: { error } }: any) => {\n            console.log(error)\n            return error\n          }\n        })\n      },\n      services: {\n        requestChange: (_, { email, options }) =>\n          api.post<string, { data: { error?: ErrorPayload } }>('/v1/auth/user/password/reset', {\n            email,\n            options: {\n              redirectTo: options?.redirectTo?.startsWith('/')\n                ? clientUrl + options.redirectTo\n                : options?.redirectTo\n            }\n          })\n      }\n    }\n  )\n}\n", "import Cookies from 'js-cookie'\n\nexport type StorageGetter = (key: string) => string | null\nexport type StorageSetter = (key: string, value: string | null) => void\nconst isBrowser = typeof window !== 'undefined'\n\n// TODO rename to 'refreshTokenGetter' and 'refreshTokenSetter'\nexport const defaultStorageGetter: StorageGetter = (key) => {\n  if (isBrowser && localStorage) return localStorage.getItem(key)\n  else {\n    console.warn('no defaultStorageGetter')\n    return null\n  }\n}\n\nexport const defaultStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser && localStorage) {\n    if (value) {\n      localStorage.setItem(key, value)\n    } else {\n      localStorage.removeItem(key)\n    }\n  } else {\n    console.warn('no defaultStorageSetter')\n    // throw Error(\n    //   'localStorage is not available and no custom storageSetter has been set as an option'\n    // )}\n  }\n}\n\nexport const cookieStorageGetter: StorageGetter = (key) => {\n  if (isBrowser) {\n    return Cookies.get(key) ?? null\n  } else {\n    return null\n  }\n}\n\nexport const cookieStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser) {\n    if (value) {\n      Cookies.set(key, value)\n      // localStorage.setItem(key, value)\n    } else {\n      Cookies.remove(key)\n      // localStorage.removeItem(key)\n    }\n  }\n}\n", "import { Nhost, NhostClientOptions } from './client'\nimport { cookieStorageGetter, cookieStorageSetter } from './storage'\nconst isBrowser = typeof window !== undefined\n\nexport class NhostSSR extends Nhost {\n  constructor({ backendUrl }: NhostClientOptions) {\n    super({\n      backendUrl,\n      autoSignIn: isBrowser,\n      autoRefreshToken: isBrowser,\n      storageGetter: cookieStorageGetter,\n      storageSetter: cookieStorageSetter\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
